\section{Теоретическая часть}
\subsection{Алгоритмы}
На сегодняшний день существует большое количество алгоритмов поиска пути, в этой работе будут рассматриваться алгоритм Дейкстры (англ. Dijkstra’s algorithm) и A* (англ. A star). Алгоритмы применимы во взвешенном графе, все рёбра которого неотрицательны. Примером такого графа является сеть дорог или сетка (англ. Grid). 
\subsubsection{Алгоритм Дейкстры}
Данный алгоритм находит кратчайший путь от стартовой вершины до любой другой в графе. Определённость конечной вершины во время работы алгоритма не требуется.
Введём обозначения:
\begin{itemize}
    \item $G = (V,E)$ — взвешенный ориентированный граф, где $V$ — множество вершин, а $E$ — множество рёбер.
    \item $s$ — исходная вершина, $v$ — текущая вершина, для которой кратчайший путь уже расчитан, $u$ — вершина, имеющая общее ребро с текущей.
    \item $\pi[v]$ — родительская вершина.
    \item $S$ — множество уже обработанных вершин.
    \item $w(u,v)$ — весовая функция, возвращает вес ребра $uv$.
    \item $g[u]$ — максимальная оценка кратчайшего пути из $s$ в $u$.
    \item $g[v]$ — длина кратчайшего пути из $s$ в $v$.

\end{itemize}

Входные данные: $G = (V,E), s$.

Выходные данные: $G = (V,E),  \forall v \in V: g[v],\pi[v]$.

Опишем алгоритм с помощью псевдокода [\ref{pseudoDijkstra}].

\begin{algorithm}
%\KwData{$G = (V,E), s$}
%\KwResult{$G = (V,E),  \forall v \in V: g[v],\pi[v]$}

\DontPrintSemicolon
$g[s]\gets 0$, $\pi[s] \gets nil$\;
\For{$u \in V, u \neq s$}{
    $g[u] \gets  \infty $\;
    $\pi[u] \gets nil$\;
}
$Q \gets \{s\}$\;
$S \gets \emptyset$\;
\While{ $ Q \ne \emptyset$}{
    $v \gets Extract-Min(Q,g[v])$\;
    $S \gets S \cup \{v\}$\;
    \For{$v \notin S, uv \in E$}{
        \If{$g[u] > g[v] + w(u,v)$} {
            $g[u] \gets d[v] + w(u,v)$\;
            $\pi[u] \gets v$\;
            $Q \gets Q \cup \{v\}$\;
        }
    }
}


\caption{Псевдокод алгоритма Дейкстры}
\label{pseudoDijkstra}
\end{algorithm}
Путь от стартовой клетки до самой себя равен нулю, поэтому в первой строчке мы приравниваем $g[s]$ к нулю, родителя $\pi[s]$ у данной клетки нет.

В строчках 2-4, происходит инициализация параметров всех вершин, кроме стартовой. Для удобства считаем $g[v]$ бесконечно большим числом.

Далее, вводятся два множества $Q$ и $S$. Первое множество содержит обрабатываемые вершины, а второе те, для которых кратчайший путь уже расчитан.

Пока множество $Q$ не пустое, из него будет переноситься в множество $S$ вершина с наименьшим $g[v]$.

Далее, в строках 12-14, для каждой смежной с ней вершиной $u$, не входящей в множество $S$, применяется основной метод алгоритма — релаксация. Эта техника заключается в хранении для каждой вершины $u$ максимальной оценки кратчайшего пути $g[u]$ из $s$ в $u$. Если из вершины $u$ кратчайший путь $g[u]$ больше при проходе через её текущего родителя, то производится пересчёт кратчайшего пути в $u$ через вершину-родителя $v$, то есть значение $g[u]$ уменьшается до $g[v] + w(u,v)$. Вершина $u$ добавляется в множество $Q$. Если $Q$ является очередью, то повторно добавлять $u$ в очередь нельзя.

После окончания работы алгоритма у каждой вершины, из которой возможен путь к стартовой, будет определён родитель $\pi[v]$ и длина кратчайшего пути $g[v]$. Чтобы пройти по вершинам, составляющим кратчайший путь необходимо двигаться от дочерней вершины к родительской, пока она не станет равна стартовой. Если же $\pi[v]$ неопределена, то найти кратчайший путь из вершины $s$ в $v$ нельзя. Такое возможно только в случае несвязанного графа.

Так как вершина после попадания в множество $S$ больше не обрабатывается, то количество итерации цикла while будет равно $V$ в случае связанного графа и меньше $V$ в случае несвязанного графа.

\subsubsection{Алгоритм A*}
Данный алгоритм находит кратчайший путь от стартовой вершины $s$ до заданной $a$.

Алгоритм эквивалентен алгоритму Дейкстры с добавлением эвристики и раннего выхода при достижении заданной вершины. Допустимая эвристическая оценка $h[u]$ — примерное расстояние от вершины $u$ до заданной $a$, непереоценивающая реальное расстояние, тогда $f[v] = g[v] + h[v]$ — примерное расстояние от $s$ до $a$.

Отличия A* от алгоритма Дейкстры показаны на псевдокоде [\ref{pseudoA}]. Так же показана работа функции pathTo, которая позволяет получить список вершин, через которые проходит кратчайший путь.

Входные данные: $G = (V,E), s, a$.

Выходные данные: $G = (V,E), g[a],\pi[a]$.

\begin{algorithm}
\DontPrintSemicolon
%\KwData{$G = (V,E), s$}
%\KwResult{$G = (V,E),  \forall v \in V: g[v],\pi[v]$}
\SetKwProg{Fn}{function}{}{end}
\Fn{pathTo(v)}{
    $path \gets \emptyset$\;
    \While{ $\exists \pi[v]$}{
        $path \gets path \cup \{v\}$\;
        $v \gets pi[v]$\;
    }
    \textbf{return} reverse($path$)\;
}

$g[s]\gets 0$, $\pi[s] \gets nil, f[s] = 0 + h[s]$\;
\For{$u \in V, u \neq s$}{
    $g[u] \gets  \infty $\;
    $\pi[u] \gets nil$\;
}
$Q \gets \{s\}$\;
$S \gets \emptyset$\;
\While{ $ Q \ne \emptyset$}{
    $v \gets$ Extract-Min($Q$,$f[v]$)\;
    $S \gets S \cup \{v\}$\;
    \If{$v = a$}{
        \textbf{exit} pathTo($v$)\;
    }
    \For{$v \notin S, uv \in E$}{
        \If{$g[u] > g[v] + w(u,v)$} {
            $g[u] \gets d[v] + w(u,v)$\;
            $\pi[u] \gets v$\;
            $f[v] \gets g[v] + h[v]$\;
            $Q \gets Q \cup \{v\}$\;
        }
    }
}


\caption{Псевдокод алгоритма A*}
\label{pseudoA}
\end{algorithm}

Теперь текущая вершина $v$ выбирается по минимальному значению $f[v]$, вычисляемому в 22 строчке для всех клеток, кроме стартовой, в множестве $Q$. Очевидно, что при $h[v]=0$ A* превращается в алгоритм Дейкстры.

В строчках 16-17 реализован ранний выход.







