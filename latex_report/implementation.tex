\section{Реализация}
\subsection{Список используемых технологий}
\begin{enumerate}
\item JavaScript — интерпретируемый браузером язык программирования.
\item HTML5, CSS — языки разметки для создания интерфейса.
\item Bootstrap, jQuery — подключённые библиотеки.
\item LaTeX — система компьютерной верстки, значительно облегчающая создание технической литературы. Используется для создания отчёта.
\item VCS Git — система контроля версий.
\end{enumerate}
\subsection{Язык программирования и библиотеки}
Для реализации поставленных задач был выбран язык JavaScript. Его программой-интерпретатором является браузер (ссылка). Язык прост в освоении, имеет похожий на язык C синтаксис, динамическую типизацию переменных, элементы объектно-ориентированного программирования позволяет работать с обработчиками событий(сслыка).

JavaScript поддерживается всеми современными браузерами, что обеспечивает реализованной программе кроссплатформенность и возможность запуска даже на мобильных устройствах.

По соображениям безопасности, на язык наложены некоторые ограничения. Он не имеет прямого доступа к операционной системе. Например, возможность чтения и записи файлов сильно ограничено.

Язык имеет полную интеграцию с языком разметки HTML и CSS. Первый позволяет создавать прототип интерфейса, его скелет, а второй определяет внешний вид объектов интерфейса.

Вместе тройка данных языков предоставляет невероятные возможности для построения интерфейса и визуализации, что хорошо подходит для осуществления поставленных задач.

Для упрощения работы подключены библиотеки jQuery и Bootstrap. jQuery используется для быстрого доступа к содержимому HTML и необходим для работы Bootstrap. Bootstrap предоставляет готовые решения для элементов интерфейса, выполненные профессиональными дизайнерами. 

Совокупность перечисленных языков и библиотек позволяет сосредоточится на алгоритмах и правильной работе коде, а не тратить время на изучение огромного количества документации к интерфейсу, как в многих решениях для компилируемых языков программирования.
\subsection{Реализации алгоритмов}
\subsubsection{Структура карты}
Граф представлен сеткой (англ. Grid) — массив клеток, который условно можно назвать картой. Каждая клетка является вершиной, имеющей 4 или 8 соседних вершин в зависимости от разрешённости диагонального движения. Координаты клетки определяются её положением в двухмерном массиве карты. Вес ребра равен дистанции между координатами [].

Рассмотрим клетку как прототип объекта. Определены поля $f$, $h$, $g$, $parent$, $closed$, $visited$, $type$, $i$, $j$. Значения первых трёх полей понятно из описания алгоритмов, приведённого выше. Поле $closed$ позволяет алгоритму понять окончательно обработана клетка или нет и избавиться от хранения объектов в закртом списке (эквивалент множества $S$) и постоянном проверке наличия в нём элементов. Поле $visited$ необходимо для избежания повторного добавления клетки в открытый список $openData$ (эквивалент множества $Q$). $i,j$ — координаты. $type$ — тип клетки, он может принимать 6 разных значений, но для алгоритма важно только является клетка проходимой или нет. Методы у клетки однотипны и завязаны на проверке клетки на тип, возвращают логический тип. 

При генерации клеток рандомно определяется в зависимости от коэффициента явлется ли клетка препятствием или нет. Пользователь может изменять топологию карты: убирать и создавать новые препятсвия.

\subsubsection{Структура поиска пути}
Для удобного использования и интеграции с интерфейсом поиск пути реализован в объекте, состоящем из методов:

\begin{itemize}
\item $ClearParams$ — входные параметры: $map$ — двумерный массив клеток. Изменяются поля каждой клетки, использующиеся в процессе работы алгоритма, до стандартных значений на случай, если поиск вызвается повторно на одной и той же карте.
\item $pathTo$ — входные параметры: $cell$ — объект-клетка. проходит по родительским клеткам, пока они существуют. Возвращает спиок клеток $path$ — кратчайший путь.
\item $getG$ — входные параметры: клетки $cell,parent$. Возвращает коэффициент $g[cell]$ при проходе через новую клеку-родителя $parent$.
\item $relax$ —входные параметры: $cell, newparent, G$. Производит релаксацию. Значение $g[cell]$ уменьшается и $cell$ присваевается новый родитель\\$newparent$.
\item $heuristic$ — входные параметры: $pos0, pos1$ — массивы координат. Расчитывает эвристическую оценку при движении из $pos0$ в $pos1$.
\item $getNeighbours$ — входные параметры: карта $map$, клетка $cell$. Возвращает массив клеток, имеющих общее ребро с $cell$.
\item $extractMin$ — входные параметры: $openData$ список. Извлекает из данного списка минимальный по $f$ элемент.
\item $isWallCorner$ — входные параметры: $cell,parent,map$. При диагональном движении из $parent$ в $cell$ определяет есть ли на пути угол препятствия. Данный метод не используется в описании алгоритма, но появляется из-за особенности grid-карт.
\end{itemize}

Основным методом является $search$. Метод вызывается из интерфейса и имеет параметры: $map, start, end, options$, где $map$ — grid-карта, $start, end$ стартовая и конечная клетка. Так как в одном методе реализован и алгоритм Дейкстры и A*, массив $options$ необходим для конфигурации поиска пути. Первый элемент отвечает за наличие диагонального движения, а второй за то, какой именно алгоритм используется. Ранний выход при достижении конечной клетки работает не зависимо от алгоритма. Метод возвращает массив из элементов: массив клеток, составляющих кратчайший путь, время работы и длину кратчайшего пути. При включённой отладке[] клетки, извлекаемые из открытого списка, помещаются в глобальный список для наглядной визуализации работы.

\subsubsection{Эвристика}
Важным элементом в реализации выступает эвристика. Мы не будет считать простую дистанцию между координатами текущей и конечной клеток, так как необходимо соблюдать единость масшаба коэффициентов $g$ и $h$. Для grid-карт есть два способа посчитать точную эвристику, то есть кратчайший путь без учёта препятствий на пути.

Первый способ — Манхэттенское расстояние, которое считает количество клеток по диагонали и вертикали, оставшихся до конечной клетки. Она очень хорошо подходит, когда диагональное движение запрещено и расчитывается по формуле:
$$
D * (|cell.x - start.x|+|cell.y-end.y|)
$$ где $D$ — это вес ребра. В нашем случае это 1.

Второй способ — диагональное расстояние. Оно используется, когда имеется возможность передвигаться по диагоналям, причём стоимость диагональных ребёр отличается от вертикальных или горизонтальных. Расчитывается по формуле:
$$
D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)
$$ где $dx=|cell.x - start.x|$, $dy=|cell.y-end.y|$, а $D2$ равен весу дианонального ребра. В нашем случае это $\sqrt{2}$.

Наглядно увидеть два данных вида точной эвристики можно увидеть на рис. \ref{manh} и \ref{diag}.

\begin{figure}[h]
\center{\includegraphics[scale=0.7]{manhattan.png}}
\caption{Манхэттенское расстояние}
\label{manh}
\end{figure}

\begin{figure}[h]
\center{\includegraphics[scale=0.7]{diagonal.png}}
\caption{Диагональное расстояние}
\label{diag}
\end{figure}

\subsection{Реализация интерфейса}
\subsubsection{Внешная спецификация}
\subsubsection{Внутренняя спецификация}
\subsubsection{Пример работы}